/*
 * Copyright (c) 2024 Tomasz Sterna
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

; Parallel RAM memory emulation on SPI SerialRAM
;
; CPU bus interface:
;
; -----+                                +-----
;      |          +-- BUFF0 <-- A0-A7   |
;      |          |     ||              |
;      |D0-D7 <---+-- BUFF1 <-- A8-A15  |
;      |          |     ||              |
; Pico |          +-> BUFF2 <-> BA0-BA7 | 65816
;  RIA |              | ||              | CPU
;      | DIR ---------+ ||              |
;      |                ||              |
;      |DE0-1 ------->74139             |
;      |                    NOR+--- VDA |
;      | VAB <----------------o+--- VPA |
;      |                                |
;      | RWB <--------------------- RWB |
; -----+                                +-----
;
; DIR - LOW: CPU->RIA (Read)
;      HIGH: RIA->CPU (Write)
;       Affects only BUFF2, BUFF0-1 are hardwired CPU->RIA
; BE0:       00: BUFF0, 01: BUFF1
; BE1:       10: BUFF2, 11: N/A  (VIA?)

; The idea is to use BUFF0-2 to "scan" address and data bus using a shared
; 8-bit Pico bus. This technique uses only 11 GPIO pins, instead of 24.
; Credits to: https://neo6502.com

; After RESET start with Φ2 HIGH
;
;   1. Drive Φ2 LOW
;   2. Wait tDHR (10ns), so CPU can Read BA0-BA7
;   3. Wait tADS (40ns)
;   4. Set DIR to Read
;   5. Set D0-D7 to IN
;   6. Read A0-A7
;      - Enable BUFF0 (BE:00)
;      - Read D0-D7
;      - Push to FIFO
;   7. Read A8-A15
;      - Enable BUFF1 (BE:01)
;      - Read D0-D7
;      - Push to FIFO
;   8. Read BA0-BA7
;      - Enable BUFF2 (BE:10)
;      - Read D0-D7
;      - Push to FIFO
;   9. Read RWB, VAB
;      - Push to FIFO
;  10. Drive Φ2 HIGH
; 11a. If RWB is LOW (Write)
;    12. Wait for RWB is LOW - this signals valid Write data on BA0-BA7
;    13. Read BA0-BA7
;        - Enable BUFF2 (BE:10)
;        - Set DIR to Read
;        - Read D0-D7
;        - Push to FIFO
;    14. Trigger PIO IRQ, so CPU can handle decoded address and data
;    15. Wait for incoming FIFO data (dummy), to signal end of RAM write
; 11b. If RWB is HIGH (Read)
;    12. Trigger PIO IRQ, so CPU can handle decoded address
;    13. Wait for incoming FIFO data
;    14. Write BA0-BA7
;        - Enable BUFF2 (BE:10)
;        - Set DIR to Write
;        - Set D0-D7 to OUT
;        - Set D0-D7 data
;
; Note: VAB signal HIGH means that CPU is doing internal stuff and does not
; provide valid address on bus. This can be used to short-circuit the loop
; and proceed to next Φ2 immediately, without reading/writing memory.
; TBD: it can be done in PIO program or in CPU interrupt routine
;

; One Pico clock cycle @208Mhz is ~4,81ns

.program mem_bus

.side_set 4
; 1: PHI2
; 2: BE0
; 3: BE1
; 4: DIR (BUFF2)

    nop                 side 0b0000 [1] ; clock LOW, BUFF0, Read, wait ~4,8ns
.wrap_target
    mov osr, null       side 0b0000 [1] ; 00000000 to OSR
    out pindirs, 8      side 0b0000 [1] ; D0-D7 in
    nop                 side 0b0000 [1] ; nop to get total 8 cycles of delay (~38,5ns)

    ; read without delay, to trigger memory read/write as fast as possible
    in  pins, 8         side 0b0010     ; read A0-A7, switch to BUFF1
    in  pins, 8         side 0b0100     ; read A8-A15, switch to BUFF2
    in  pins, 10        side 0b0101     ; read BA0-BA7,RWB,VAB, set clock HIGH

    ;; FIXME: assume CPU is reading (RWB is HIGH)
    irq set 0           side 0b0101     ; request processing by Pico CPU code
    mov osr, ~null      side 0b0101     ; 11111111 to OSR, and wait ~10ns for bus release
    out pindirs, 8      side 0b1101     ; D0-D7 out, clock still HIGH, BUFF2 Write
    pull                side 0b1101     ; pull reply to OSR
    set x, 5            side 0b1101 [1] ; loop to get total 14 cycles of delay (~67ns)
loop:
    jmp x-- loop        side 0b1101
    out pins, 8         side 0b1101 [1] ; wait ~10ns
    nop                 side 0b1100 [1] ; clock LOW
.wrap


; This programs talk to 4x ISSI IS66 32Mb SerialRAM using SPI/QPI protocol
;
;  IN/OUT: SIO0-3
;     SET: CE0-1
; SIDESET: CLK

; QPI mode program, used for data write
; pushes TX fifo incoming as 8bit bytes, as fast as possible
.program mem_qpi_write
.side_set 1
    out pins, 4         side 0  ; Push command (2 nybbles) and address (6 nybbles)
    nop                 side 1  ; and following data

; QPI mode program, used for reading
; it needs to send command and possibly address, than switch to reading
; reads until got reset by firmware
;
; X - how many nybbles to output
; Y - how many delay cycles before read
.program mem_qpi_read
.side_set 1

; memory needs 6 wait cycles
; -1 cycle used for changing pindirs
; -1 because loop is indexed from 0
.define wait_cycles     (6 - 1 - 1)

    mov osr, ~null      side 0  ; Load ones to OSR
    out pindirs, 4      side 0  ; Set SIO0-3 to OUT mode (we are going to send command)

    set y, wait_cycles  side 0  ; set Y with wait cycles

    ; now wait for TX data
    pull                side 0  ; pull memory bank select instruction
    out exec, 16        side 0  ; Exec Memory bank select (CE0-1) encoded as "set pins, .." instruction
    out x,    16        side 0  ; Load how many nybbles of command to transmit

loop:
    out pins, 4         side 0  ; Push command (2 nybbles) and maybe address (6 nybbles)
    jmp x-- loop        side 1  ; X was set to how many

    mov osr, null       side 0  ; Load zeros to OSR
    out pindirs, 4      side 1  ; Set SIO0-3 to IN mode (we are going to read command reply)

delay:
    nop                 side 0  ; Memory requires 6 delay cycles after providing command
    jmp y-- delay       side 1  ; Y was set to how many

.wrap_target
    nop                 side 0  ; Now read as many bytes as Pico CPU or DMA
    in pins, 4          side 1  ; requests (2 nybbles for each)

; SPI mode program, used solely to reset and read ID
.program mem_spi
.side_set 1

    mov osr, ~null      side 0  ; Load ones to OSR
    out pindirs, 4      side 0  ; Set SIO0-3 to OUT mode (we are going to send command)

    pull                side 0
    set x, 31           side 0  ; Push 32 (0 counting) bits of command (8) + address (24)
loop:
    out pins, 1         side 0
    jmp x-- loop        side 1

    mov osr, null       side 1  ; Load zeros to OSR
    out pindirs, 4      side 1  ; Set SIO0-3 to IN mode (we are going to read command reply)

.wrap_target
    nop                 side 0  ; Now read as many bytes as Pico CPU or DMA
    in pins, 1          side 1  ; requests
