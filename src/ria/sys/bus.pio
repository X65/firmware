/*
 * Copyright (c) 2024 Tomasz Sterna
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

; Parallel RAM memory emulation on SPI SerialRAM
;
; CPU bus interface:
;
; -----+                                +-----
;      |          +-- BUFF0 <-- A0-A7   |
;      |          |     ||              |
;      |D0-D7 <---+-- BUFF1 <-- A8-A15  |
;      |          |     ||              |
; Pico |          +-> BUFF2 <-> BA0-BA7 | 65816
;  RIA |              | ||              | CPU
;      | DIR ---------+ ||              |
;      |                ||              |
;      |BE0-1 ------->74139             |
;      |                    NOR+--- VDA |
;      | VAB <----------------o+--- VPA |
;      |                                |
;      | RWB <--------------------- RWB |
; -----+                                +-----
;
; DIR - LOW: CPU->RIA (Read)
;      HIGH: RIA->CPU (Write)
;       Affects only BUFF2, BUFF0-1 are hardwired CPU->RIA
;
; BE0:       00: BUFF0, 01: BUFF1
; BE1:       10: BUFF2, 11: High Impedance

; The idea is to use BUFF0-2 to "scan" address and data bus using a shared
; 8-bit Pico bus. This technique uses only 11 GPIO pins, instead of 24.
; Credits to: https://neo6502.com

; After RESET start with Φ2 HIGH
;
;   1. Drive Φ2 LOW
;   2. Wait tDHR (10ns), so CPU can Read BA0-BA7
;   3. Wait tADS (40ns)
;   4. Set DIR to Read
;   5. Set D0-D7 to IN
;   6. Read A0-A7
;      - Enable BUFF0 (BE:00)
;      - Read D0-D7
;      - Push to FIFO
;   7. Read A8-A15
;      - Enable BUFF1 (BE:01)
;      - Read D0-D7
;      - Push to FIFO
;   8. Read BA0-BA7
;      - Enable BUFF2 (BE:10)
;      - Read D0-D7
;      - Push to FIFO
;   9. Read RWB, VAB
;      - Push to FIFO
;  10. Drive Φ2 HIGH
; 11a. If RWB is LOW (Write)
;    12. Trigger PIO IRQ, so CPU can handle decoded address
;    13. Read BA0-BA7
;        - BUFF2 (BE:10) should already be enabled
;        - DIR should already be Read
;        - Read D0-D7
;        - Push to FIFO
;    14. Loop to next PHI2 cycle
; 11b. If RWB is HIGH (Read)
;    12. Trigger PIO IRQ, so CPU can handle decoded address
;    13. Wait for incoming FIFO data
;    14. Write BA0-BA7
;        - Enable BUFF2 (BE:10)
;        - Set DIR to Write
;        - Set D0-D7 to OUT
;        - Set D0-D7 data
;
; Note: VAB signal HIGH means that CPU is doing internal stuff and does not
; provide valid address on bus. This can be used to short-circuit the loop
; and proceed to next Φ2 immediately, without reading/writing memory.
;

; Timings:
;
; https://www.ti.com/lit/ds/symlink/sn74lvc139a.pdf
; SN74LVC139 decoder needs:  (MIN/MAX) at 3.3V
; tPD : 1/6.2 ns - input->output propagation delay
;
; https://www.ti.com/lit/ds/symlink/sn74lvc245a.pdf
; 74LVC245 buffers need:  (MIN/TYP/MAX) at 3.3V
; tPD : 1.5/3.8/6.1 ns - A->B / B->A - input->output propagation delay
; tEN : 1.4/4.4/8.3 ns - OE -> A/B   - output enable delay
; tDIS: 1.7/4.1/7.3 ns - OE -> A/B   - output disable delay
; - This means that we need to wait MAX(tEN,tDIS) when switching BUFF using BE0/1
;    before we can read/write the buffer output.
; - We also need to wait MAX(tADS,tBAS)+tPD after transitioning PHI2 LOW for address
;   and wait tMDS+tPD until reading the data bus when CPU is writing to memory.
;
; https://www.westerndesigncenter.com/wdc/documentation/w65c816s.pdf
; WDC65C816 signals need:  (Min/Max) at 3.3V
; tCYC : 125/--- ns - Full clock Cycle Time (this means 8MHz max)
; tPWL :  63/    ns - Clock Pulse Width Low
; tPWH :  62/    ns - Clock Pulse Width High
; tF,tR: ---/  5 ns - Clock Fall/Rise Time
; tAH  :  10/    ns - A0-A15 Hold Time  (old Axx after PHI2 gets low)
; tADS :    / 40 ns - A0-A15 Setup Time (new Axx after PHI2 gets low)
; tBH  :  10/    ns - BA0-BA7 Hold Time (old DATA after PHI2 gets low)
; tBAS :    / 40 ns - BA0-BA7 Setup Time (high ADDRESS after PHI2 gets low)
; tACC :  70/    ns - Access Time
; tDHR :  10/    ns - Read Data Hold Time
; tDSR :  15/    ns - Read Data Setup Time
; tMDS :    / 40 ns - Write Data Delay Time
; tDHW :  10/    ns - Write Data Hold Time
; - Processor reads data bus on falling edge of PHI2 clock (read cycle).
;   Data needs to be provided at least tDSR before PHI2 gets LOW
;   and hold tDHR after PHI2 change, so CPU can read it stable.
;   It can read (react to PHI2 change) as fast as tACC after setting the address bus (tADS).
; - After PHI2 gets LOW, processor provides A0-A15 on the address bus (after tADS)
;   and A16-A23 on the data bus (after tBAS) until clock gets HIGH again.
; - When writing to memory, the processor provides data on data bus after tMDS
;   up to the falling edge of PHI2 clock + tDHW. (write cycle)
;
; The fastest operation we need to do is fast switch the BUFF0-2 buffers, to scan
; over the address bus (A0-A15). This takes tPD of decoder + MAX(tEN,tDIS) of buffer
; max: 6.2 ns + 8.3 ns = 14.5 ns
; typ: (4) ns + 4.4 ns = 8,4 ns
; min:   1 ns + 1.7 ns = 2,7 ns
;
; One Pico clock cycle @336MHz is ~2.97619ns.
;
; After the CPU address bus (tADS) and data bus (tBAS) are stable, it takes us
; 1. 9 PIO instructions to be ready to get data bus (when CPU is writing)
;   - 40 ns of tMDS => 4.(444) ns for one PIO instruction
; 2. 14 PIO instructions to provide data bus data (when CPU is reading)
;   - 70 ns of tACC => 5 ns for one PIO instruction
;
; With above timings we minimum workable PIO instruction time is 4.4ns.
; But having minimum of 9 instructions per LOW half-cycle (TPWL)
; and 7 instructions per HIGH half-cycle (tPWH), gives:
; 63ns / 9 = 7ns
; 62ns / 7 = 9ns
; Which leaves us with minimum 9ns per PIO instruction => 111,111MHz

.define PUBLIC WRITE_DELAY 17

.program mem_bus

.side_set 4
; 1: PHI2
; 2: BE0
; 3: BE1
; 4: DIR (BUFF2)

.wrap_target
start:
    mov osr, null       side 0b0000 [1] ; 00000000 to OSR, clock LOW, BUFF0, Read
    out pindirs, 8      side 0b0000 [1] ; set D0-D7 as inputs
    nop                 side 0b0000 [1] ; nop to get 40ns of delay (tADS,tBAS) (6 cycles + 1 from jmp/wrap)

    ; switch over buffers as fast as possible
    in  pins, 8         side 0b0010     ; read A0-A7, switch to BUFF1
    in  pins, 8         side 0b0100     ; read A8-A15, switch to BUFF2
    in  pins, 16        side 0b0101     ; read BA0-BA7,VAB,RWB,... set clock HIGH

    ; At this point RX fifo is autopushed, and CPU core1 will process the access
    ; While Pico is processing the data, we can make decision what to do next
    mov osr, ~pins      side 0b0101     ; load _negated_ pins
    out null, 8         side 0b0101     ; throw away data bus
    out y, 1            side 0b0101     ; load VAB to Y
    jmp !y, start       side 0b0101     ; if address is invalid, proceed immediately to next cycle

    out y, 1            side 0b0101     ; load RWB to Y
    jmp !y, read        side 0b0101     ; if _negated_ RWB is low, means Read

write:
    ; CPU is writing (RWB is LOW)
    ; need to wait tMDS (40ns) after PHI2 transition HIGH
    set x, WRITE_DELAY  side 0b0101     ; loop to get create delay
loop:
    nop                 side 0b0101 [1]
    jmp x-- loop        side 0b0101 [1]
    in  pins, 32        side 0b0100     ; read BA0-BA7, set clock LOW
    jmp start           side 0b0000     ; continue to next cycle

read:
    ; CPU is reading (RWB is HIGH)
    ; need to wait tACC (70ns) since tADS until CPU is ready to read data bus (15,68 cycles)
    mov osr, ~null      side 0b0101     ; 11111111 to OSR
    out pindirs, 8      side 0b1101     ; D0-D7 are outputs, clock still HIGH, BUFF2 Write
    pull                side 0b1101 [1] ; pull CPU reply to OSR
    nop                 side 0b1101 [1] ; need 3 more cycles of delay (tACC) (2 here + 1 above)
    out pins, 8         side 0b1101 [1] ; drive data bus
    nop                 side 0b1101 [1] ; wait ~10ns (tDSR) for data bus to stabilize (2+1)
    nop                 side 0b0000     ; clock LOW
.wrap
